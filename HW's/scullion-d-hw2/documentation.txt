Audio Effects:
    I wen't with the treble and base effeect nodes as was taught in the videos. They don't have the same exact values, I made the treble node less prevalent and the base node more prevelant, as I felt the base node didn't change enough and the treble changed too much. 
Classes:
    I had three ES6 classes but only two of them count as sprites. 

    My circle class was used for a Confetti/falling ash type effect, where little circles fall from the sky and sort of float around downwards into the wind. I've made it so that there are 30 at any given time. Any that go off the left side of the screen return from the right and vice versa. When they reach the bottom of the screen they teleport to the top. I'm essentially just reusing the same sprites over and over, however, the positions and sizes, and therefore the speeds, are randomized each page reload, so it will always be different. All circles will grow in size and speed as the average of the frequencys grows larger. This class is actually adapted from and moderatly modified from this one found online: https://codepen.io/Mertl/pen/GexapP, so some credit does go there.

    My Sphere sprite makes heavy use of my Point Class. It's essentially a 3-dimensional ball, programmed in a 2-dimensionl plane. It might not be an overstatment to say that over 80% of my project was just me working on this. I don't think I can explain all of it in this small part of documentation so I'll just cover the large points. The sphere doesn't use arcs, It's made up of multiple rings, which are in turn made up of several instances of the Point class, which acts in 3 dimensions. Instead of using arcs, I draw a path between all points in a ring. It actively uses two different colors at all times, seperated along the fictional z axis. This color differentiation actually constituted 50% of making the sphere, as there are an unbelievable amount of edge cases when it comes to sorting points apparently. The colors are useful for depth, which is very apparent when the sphere is spinning, which is one of the two ways that it can interact with the soundData. I essentially devided all of the sound data into averages of 3 groups: bass, middle, and treble. The bass controls the x axis rotation, the middle controls the y axis rotation, and the treble controls the z axis rotation. Suffice it to say, a lot of x axis rotation, little z axis rotation. The other way that the sphere can react is by pulsing. Each of the rings is affected by a different range of soundData, and will pulse up to double their radius based on the average value of their sound data. Color will also get lighter as rings get larger, turning white at their extent. Ironically, because base is often prominent and the max treble range is rarely used, this often makes the sphere look like a speaker or earbud.

JSON 
    I had the av-data.json hold the title, songs and drawing parameters. When init runs, this data gets read by the program. All data in drawParameters is copied over to the drawParameters in main.js. The title is read and appended to the top of the html page in an <h1>. Likewise, all the songs and their attatched mp3s are appended to the list in the html, which makes it really easy to add additional music in the future if I wanted to. 

Aesthetics
    Most of the assignment information is ambiguous and even the things that seem like they might be requirenments are worded in a way that makes that inconclusive. Aesthetics are generally difficult for me, and I focused a lot more on additions than deletions. It was suggested(?) that we remove the gradient, but I actually really liked the look of my gradient, and it's basic tones felt really thematic with the two tone sphere I was going for. In all honesty, theres not much that comes to mind in good 2D environments if you're going to plop a simply colored 3D sphere in the middle of the environment. I ended up making the bars more of a background element than a main one and made them a bit more transparent to blend with the background instead of giving them their own distinct and ever changing color. I also changed the shape of the bars to be more pleasing, and I might have halved the amount but it's hard to remember. 

    Waveform audio caught me really off gaurd as I coulndn't really find a way to design around it. The problem is that it changes blisteringly fast, and even trying to change the fps couldn't really stop that from being a problem. It's noticably a bigger problem on the default song than the other two. I ended up having a seperate data array that just averages the previous and current change, so it changes a bit more slowly. This at least took it out of eptilieptic territory. I ended up changing the bars to be centered because It was the only way I could really convey the waveform visually. All other options from the previous exercises were also included in this one. 

Grade
    A "wow" experience and a meaningful improvment don't exactly go hand in hand, I feel like I nailed the former whilst the latter is questionable. In effort I would give myself a 15%. I've been working so long that I've had benign essential blepharospasm in my left eye all day (true story). I think it looks aestheticaly pleasing, though I know my tastes are much different than other peoples, and I didn't touch or spend too much time on the UI. All things considered I would give between a 10% and 15% for that section. 